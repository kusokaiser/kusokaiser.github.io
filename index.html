<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Kaiser&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="a personal blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Kaiser's blog">
<meta property="og:url" content="http://kusokaiser.github.io/index.html">
<meta property="og:site_name" content="Kaiser's blog">
<meta property="og:description" content="a personal blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Kaiser's blog">
<meta name="twitter:description" content="a personal blog">
  
    <link rel="alternate" href="/atom.xml" title="Kaiser&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Kaiser&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://kusokaiser.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="[post]-20170707-React相关技巧和实践-郭琦" class="article article-type-[post]" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/06/20170707-React相关技巧和实践-郭琦/" class="article-date">
  <time datetime="2017-07-06T07:16:50.000Z" itemprop="datePublished">2017-07-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/06/20170707-React相关技巧和实践-郭琦/">React相关技巧和实践</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="React相关技巧和实践"><a href="#React相关技巧和实践" class="headerlink" title="React相关技巧和实践"></a>React相关技巧和实践</h1><p><img src="http://i.imgur.com/3tqrwK2.jpg" alt=""></p>
<h3 id="1-setState回调"><a href="#1-setState回调" class="headerlink" title="1.setState回调"></a>1.setState回调</h3><p>react的setState是一个异步方法，一般会在render的时候生效，如果在某些情况下想要在改变state同时进行类似刷表的操作，例如：</p>
<pre><code>componentWillReceiveProps(nextProps){
        this.setState({
            level: nexprops.level
       });
       this.reloadTable();
}

reloadTable(){
    const level = this.state;//此时level还是之前的level，在componentWillReceiveProps中改变的state还没有生效
}
</code></pre><p>这种情况在reloadTable中的level还是之前的level，在componentWillReceiveProps中改变的state还没有生效，解决这个问题的方法有很多种方式，比如使用一些全局变量，例如this.queryLevel来缓存改变的状态，facebook官方也推荐了两种方式，</p>
<pre><code>    setState() does not always immediately update the component. It may batch or defer the update until later. 
This makes reading this.state right after calling setState() a potential pitfall. Instead, use componentDidUpdate 
or a setState callback (setState(updater, callback)), either of which are guaranteed to fire after the update has 
been applied. If you need to set the state based on the previous state, read about the updater argument below.
</code></pre><p>其中，使用setState回调是我个人比较推荐的一种方法是在setState里加回调函数，如下：</p>
<pre><code>componentWillReceiveProps(nextProps){
    this.setState({
        level: nexprops.level
    },()=&gt;{this,reloadTable()});
}

reloadTable(){
    const level = this.state;//此时level为新的level
}
</code></pre><p>setState中的回调函数可以保证在本次state更改后才会执行。</p>
<h3 id="2-为什么我们的组件绑定方法时要加上bind-this"><a href="#2-为什么我们的组件绑定方法时要加上bind-this" class="headerlink" title="2.为什么我们的组件绑定方法时要加上bind(this)"></a>2.为什么我们的组件绑定方法时要加上bind(this)</h3><p>JavaScript 的 this 关键字会造成诸多困扰。由于 JavaScript 不具备如 Java 等语言的严格类模型，因而除非是在处理回调，否则代码中的this 指向并不清晰。</p>
<pre><code>class Buttons extends Component{
    //render
    &lt;span styleName=&quot;inline-item&quot;&gt;
        &lt;Select value=&quot;修改状态&quot; styleName=&quot;sel-width&quot; onSelect={this.statusChange.bind(this)} &gt;
            {this.statusOptions()}
        &lt;/Select&gt;
    &lt;/span&gt;

    statusChange(value){
        //这里的this并没有指向class本身，而是指向了点击的那个option
        let me = this, selectArr = this.selectArr;
        if (selectArr.length &gt; 0) {
            let params = [];
            for (let i = 0; i &lt; selectArr.length; i++) {
                params.push([&quot;planIdArr&quot;, me.getCpcPlanIdArr()[i]]);
            }
            switch (value) {
                case &apos;0&apos; :
                    me._doStatus(0,params);
                    break;
                case &apos;1&apos; :
                    me._doStatus(1,params);
                    break;
                case &apos;2&apos; :
                    me._doDel(params);
                    break;
            }
        }
        return false;
    }
}
</code></pre><p>在原来 React.createClass 中， statusChange() 在onSelect事件触发的时候，会自动绑定到Buttons实例上，这时候该函数的this的上下文就是该实例。不过在ES6的class的写法(extends React.Component)中，Facebook取消了自动绑定，实例化Buttons后，statusChange()的上下文是select的支撑实例（ backing instance ）</p>
<ul>
<li><p>支撑实例</p>
<p>  ReactDOM.render() 通过将 React 元素渲染到现有的 DOM 元素中来生成一个组件实例，该实例可以访问组件类中定义的方法，但组件实例不是真实 DOM 节点。渲染组件实例产生的真实DOM元素被称为<strong>组件支撑实例</strong>，访问它的主要方式是使用ReactDOM.findDOMNode()。</p>
</li>
</ul>
<p>所以，我们发现，通过es6的方式继承React.Component的方式来定义一个类，是无法自动绑定上下文的，那么如何解决这个问题？</p>
<ul>
<li><p>bind(this)</p>
<p>  可以在class声明中的constructor()函数中，使用this.statusChange = this.statusChange.bind(this);该方法是一个bind()绑定，多次使用。在该方法中，我们在声明该实例后，可以在该实例任何地方使用 statusChange() 函数，并且该 statusChange() 函数的this的上下文都是Buttons实例对象。</p>
<p>  除此我们也可以在具体使用该函数的地方绑定this的上下文到Buttons实例对象，代码如下</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Select value=&quot;修改状态&quot; styleName=&quot;sel-width&quot; onSelect=&#123;this.statusChange.bind(this)&#125; &gt;</span><br><span class="line">		&#123;this.statusOptions()&#125;</span><br><span class="line">&lt;/Select&gt;</span><br></pre></td></tr></table></figure>
<p>  这种方法需要我们每次使用bind()函数绑定到组件对象上。</p>
</li>
<li><p>es6箭头函数</p>
<p>  es6中新加入了箭头函数=&gt;，箭头函数除了方便之外还有而一个特征就是会将函数的this绑定到其定义时所在的上下文。这个特征也可以帮助我们解决这个问题。使用方式有2种：</p>
<p>  第一种，在定义方法时使用箭头函数</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">statusChange = ()=&gt;&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  第二种，在组件属性上使用箭头函数</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Select value=&quot;修改状态&quot; styleName=&quot;sel-width&quot; onSelect=&#123;()=&gt;this.statusChange()&#125; &gt;</span><br><span class="line">		&#123;this.statusOptions()&#125;</span><br><span class="line">&lt;/Select&gt;</span><br></pre></td></tr></table></figure>
<p>  这样this.handleClick() 的上下文就会被绑定到LikeButton的实例对象上。个人认为，使用箭头函数使得JavaScript更加接近面向对象的编程风格。</p>
</li>
</ul>
<h3 id="3-优化尝试"><a href="#3-优化尝试" class="headerlink" title="3.优化尝试"></a>3.优化尝试</h3><p>之前讲到，react架构的性能优化，大多都是通过组件的shouldComponentUpdate来进行的，很多情况是通过shallowEqual对比新旧的state来判断是否需要更新，因为shallowEaqual是浅层判断，对于复杂的props数据结构有一定的隐患。在我们旭日新版中，由于我们的hash带上了一个table参数，表示当前所在的列表，那么我们完全可以利用这个参数去做一些简单的优化，在每一个推广管理的列表中加入类似如下的内容：</p>
<pre><code>shouldComponentUpdate(nextProps){
    const {query} = nextProps.location;
    const {table} = query;
    return table === HASH_PARAM_TAP_IDEA;//只有当前在idea页面，才需要更新组件
}
</code></pre><p>这样，当进入关键词tab时，不会去无谓的更新创意列表，虽然react有dom diff，可以保证在绝大多数情况下，都不会做无谓的渲染dom的操作，但如果在shoulComponentUpdate这个周期阻止更新的话，可以避免执行componentWillUpdate，render,componentDidUpdate这几个方法的，尤其是render方法，有时候在render里可能会有一些运算逻辑。对计划、组、创意和关键词列表加了如上的shoulComponentUpdate后，效果如下所示：</p>
<p>之前：<img src="http://i.imgur.com/NlZjnbQ.png" alt=""></p>
<p>之后：<img src="http://i.imgur.com/5aMcL5y.png" alt=""></p>
<p>在James·K·Nelson的一篇文章中介绍了关于何时使用shuoldComponentUpdate方法，通篇思想大致总结为以下几点：</p>
<ul>
<li><strong>添加shouldComponentUpdate方法一般都会拖慢组件的更新速度。</strong></li>
<li><strong>如果render的返回值很小，但props是个大家伙，那自己写shouldComponentUpdate很可能不会带来什么好结果。</strong></li>
<li><strong>使用shouldComponentUpdate得到的收益一般是微乎其微的。</strong></li>
<li><strong>shouldComponentUpdate很难维护</strong></li>
</ul>
<p>那么什么时候需要shouldComponentUpdate？</p>
<p>文章中写道<strong>只有经过测量，发现有了shouldComponentUpdate后组件的渲染速度确实有可察觉的提升，你才应该用它。</strong></p>
<h3 id="4-warning引起的死循环问题"><a href="#4-warning引起的死循环问题" class="headerlink" title="4.warning引起的死循环问题"></a>4.warning引起的死循环问题</h3><p>在开发附加创意时遇到一个比较匪夷所思的问题:</p>
<p>componentWillReceiveProps方法中如果有未定义的变量，会报出一个warning：<br><img src="http://i.imgur.com/mfXl6KG.png" alt=""><br>再搭配着loadTable方法中如下的写法：</p>
<pre><code>//查表
this.props.dispatch({type: ACTION_MANAGE_TABLE_MULTIPIC_LIST_DATA_SAGA, payload: this.getParams()});
this.props.dispatch({type: ACTION_MANAGE_TABLE_MULTIPIC_COUNT_REQUEST_SUCCESS, payload: &apos;&apos;});
</code></pre><p>会导致在table/index中出现死循环。具体见代码</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://kusokaiser.github.io/2017/07/06/20170707-React相关技巧和实践-郭琦/" data-id="cj4s7mhvv00005spcrj56uab5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react/">react</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web/">web</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="[post]-React开发技巧-生命周期实战技巧" class="article article-type-[post]" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/18/React开发技巧-生命周期实战技巧/" class="article-date">
  <time datetime="2017-05-18T08:16:50.000Z" itemprop="datePublished">2017-05-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/18/React开发技巧-生命周期实战技巧/">React生命周期原理和实战技巧</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="http://i.imgur.com/o7LhbGX.jpg" alt=""></p>
<p><strong>完整的生命周期流程</strong></p>
<ol>
<li>constructor(props)</li>
<li>componentWillMount()</li>
<li>render()</li>
<li><p>componentDidMount()</p>
</li>
<li><p>componentWillReceiveProps(nextProps)</p>
</li>
<li>shouldComponentUpdate(nextProps, nextState)</li>
<li>componentWillUpdate(nextProps, nextState)</li>
<li>render( )</li>
<li>componentDidUpdate(prevProps, prevState )</li>
<li>componentWillUnmount( )</li>
</ol>
<h2 id="Mount流程"><a href="#Mount流程" class="headerlink" title="Mount流程"></a>Mount流程</h2><ol>
<li>constructor()</li>
<li>componentWillMount()</li>
<li>render()</li>
<li>componentDidMount()</li>
</ol>
<p>mount意为【安装】或者【挂载】，mount流程的方法，在组件的生命周期中只会加载一次。除非页面刷新，或者组件重新被挂载，而此时意味着重新开启了组件的生命周期</p>
<h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor()"></a>constructor()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">	<span class="keyword">super</span>(props);</span><br><span class="line">	<span class="keyword">this</span>.state = &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>super(props) 必须在最前面</li>
<li>this.state 是替代getInitialState方法的写法</li>
<li><h3 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount()"></a>componentWillMount()</h3>在客户端和服务端都只会调用一次，在第一次渲染发生前触发。如果在这个方法内部初始化或更新组件的state，render()会使用更新后的state，并且只渲染一次（尽管state更新了）。</li>
</ul>
<p>也就是说在此方法内部调用setState不会走更新流程</p>
<p>父组件的该方法会在子组件的该方法之前被调用。同级别多个子组件的该方法会按照组件在dom树中的先后顺序被调用</p>
<p>适合做：</p>
<h3 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount()"></a>componentDidMount()</h3><p>在客户端只会调用一次（服务端不会调用），在第一次渲染发生后触发。在这个方法里面，你可以访问到组件的子组件的refs（比如访问底层的DOM）。子组件的componentDidMount()会在父组件的componentDidMount()之前调用。<br>如果你想整合其他Javascript框架，调用settimeout或者setInterval，或者发送AJAX请求，可以在这个方法进行。</p>
<p>这个方法被调用时，React组件已经被渲染到真实的dom树中了。该方法中如果调用this.setState会触发再次render的流程，常规情况下（不做任何的声明周期干预处理）当前组件和所有子组件的render方法被依次调用。</p>
<p>适合做：</p>
<ul>
<li>Ajax请求</li>
<li>要对真实DOM进行的操作</li>
<li>jQuery操作</li>
</ul>
<h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><ul>
<li>此时state和props已经更新</li>
<li>不能调setState，会死循环</li>
<li>最好只做render，避免复杂的计算逻辑</li>
</ul>
<h2 id="componentWillReceiveProps-object-nextProps"><a href="#componentWillReceiveProps-object-nextProps" class="headerlink" title="componentWillReceiveProps(object nextProps)"></a>componentWillReceiveProps(object nextProps)</h2><p>组件第一次mount时不会调用该方法，只有当mount之后，组件的props发生变化并被重新render时才会调用该方法。</p>
<p>此时this.props是旧的props，nextProps是最新的props<br>组件接收到新的props时，render()将会触发，在render()触发前可以在这个方法里通过this.setState()更新组件的state，此时不会触发额外的渲染。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      likesIncreasing: nextProps.likeCount &gt; <span class="keyword">this</span>.props.likeCount</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>适合做：</p>
<p>需要注意的是，这个方法被执行时，组件的props并没有发生变化。</p>
<h2 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean shouldComponentUpdate(object nextProps, object nextState);</span><br></pre></td></tr></table></figure>
<p>这个方法会在update流程中被调用：</p>
<ul>
<li>父组件的render使得当前组件的props发生变化，会依次调用componentWillReceiveProps和shouldComponentUpdate</li>
<li>当前组件内（比如在componentDidiMount中）调用了this.setState方法</li>
<li><p>如果显式声明了该方法，则必须显式地返回一个boolean值，否则会报错</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning: Child1.shouldComponentUpdate(): Returned <span class="literal">undefined</span> instead <span class="keyword">of</span> a boolean value. Make sure to <span class="keyword">return</span> <span class="literal">true</span> or <span class="literal">false</span>.</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果返回true，则组件会执行render方法；否则不会执行</p>
</li>
<li>第一次渲染和forceRender不会调用该方法</li>
<li>默认该方法返回true，如果遇到性能问题，可以在这里进行一些不必要的渲染排除的优化</li>
<li>在该方法内调用setState()会有一些奇怪的逻辑出现：<ul>
<li>并不会重新出发一个update流程</li>
<li>不会死循环</li>
<li>当前这一次render时的state还是上一次的state</li>
<li>新的state会默认在下一次render的时候生效</li>
</ul>
</li>
<li>改方法返回false时，只会影响本组件的render，不会影响子组件的render，如果通过其他事件交互，直接修改了子组件的props，子组件仍然会执行update流程</li>
<li>注意，根据 <a href="https://facebook.github.io/react/docs/react-component.html#shouldcomponentupdate" target="_blank" rel="external">React 官方</a> 的说法，就算 shouldComponentUpdate( ) 方法返回 false，组件也会重新渲染。需要随时注意官方文档的变化。?????</li>
</ul>
<p>适合：</p>
<ul>
<li>渲染的性能优化</li>
<li>和非React组件混用时，需要阻止更新流程对组件的影响时，可以返回false，自己来写更新逻辑</li>
</ul>
<h2 id="componentWillUpdate"><a href="#componentWillUpdate" class="headerlink" title="componentWillUpdate"></a>componentWillUpdate</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> componentWillUpdate(object nextProps, object nextState)</span><br></pre></td></tr></table></figure>
<ul>
<li>第一次挂载时不会执行，接收到新的<code>props</code>和<code>state</code>时，如果<code>shouldComponentUpdate</code>返回了true则会执行该方法；</li>
<li>这个方法里不能执行<code>setState</code>操作，如果执行就有可能会造成死循环</li>
<li>这一步state和props还没有更新</li>
</ul>
<h2 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate"></a>componentDidUpdate</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> componentDidUpdate(object prevProps, object prevState)</span><br></pre></td></tr></table></figure>
<ul>
<li>当更新重新渲染到dom之后，此方法会立即被调用。第一次渲染不会触发。</li>
<li>此方法是在更新后操作dom的合适的地方</li>
<li>此时state和props已经更新</li>
</ul>
<h2 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> componentWillUnmount()</span><br></pre></td></tr></table></figure>
<ul>
<li>组件从DOM中卸载前，此方法会被调用。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://kusokaiser.github.io/2017/05/18/React开发技巧-生命周期实战技巧/" data-id="cj4s7mhw100015spc5rblguks" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react/">react</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="[post]-webpack2.0" class="article article-type-[post]" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/14/webpack2.0/" class="article-date">
  <time datetime="2017-04-14T08:16:50.000Z" itemprop="datePublished">2017-04-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/14/webpack2.0/">Webpack2.0</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="webpack2-0有哪些变化？能给我们带来什么？为什么要升级？"><a href="#webpack2-0有哪些变化？能给我们带来什么？为什么要升级？" class="headerlink" title="webpack2.0有哪些变化？能给我们带来什么？为什么要升级？"></a>webpack2.0有哪些变化？能给我们带来什么？为什么要升级？</h3><hr>
<p><strong>变化</strong></p>
<p><strong><em>1.webpack2增加对es6模块的支持，也就是说webpack可以识别import和export了，不需要转换成commonJS的格式，例如我们的懒加载方式可以改为：</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function onClick() &#123;</span><br><span class="line">  import(&quot;./module&quot;).then(module =&gt; &#123;</span><br><span class="line">    return module.default;</span><br><span class="line">  &#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(&quot;Chunk loading failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并且，如果加载 chunk 失败，我们可以进行处理，因为现在它基于promise，如果你想让webpack解析这些es6的符号，那么需要做如下配置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    [&quot;es2015&quot;, &#123; &quot;modules&quot;: false &#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>2.resolve的extension中不需要再传一个空字符串了</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">    extensions: [&apos;.js&apos;, &apos;.jsx&apos;, &apos;.json&apos;, &apos;.es6.js&apos;],</span><br><span class="line">    alias: &#123;</span><br><span class="line">        &apos;backbone&apos;: path.resolve(process.cwd(), &apos;res/js/lib/backbone/backbone&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>其实，不仅仅是不需要了，而是不可以再传了，否则会报错……</p>
<p><strong><em>3.webpack中的resolve解析规则</em></strong></p>
<p>解析路径分为三类，绝对路径、相对路径、模块路径，前两个好理解，模块路径是根据什么去查找的呢，原来在resolve的配置中有一个modules配置项，默认为node_modules，如果不进行配置，则webpack会去node_modules目录下查找对应的包名去解析，我们有时会在工程目录下建一个lib路径，下面存放一些可能定制化的一些组件，需求是让webpack优先查找我们工程下的定制组件，如果不存在，则再去node_modules里去查找解析，应对这种情况，我们可以如下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resolve:&#123;</span><br><span class="line">    modules:[path.resolve(__dirname, &quot;src&quot;), &quot;node_modules&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，优先级按照数组中的顺序执行</p>
<p><strong><em>4.modules中的loaders:</em></strong></p>
<ul>
<li><p>链式调用：<br>在 v1 版本中，loaders 通常被用!连写。这一写法在新版中只在使用旧的module.loader时有效。在v2版本中，链式调用被放到了数组中：<br>use:[“style-loader”,”css-loader”,”less-loader”]<br>链式调用的执行原理是，上一个loader的输出被作为下一个loader的输入</p>
</li>
<li><p>取消了自动添加-loader的功能</p>
</li>
</ul>
<p><strong><em>5.extractTextPlugin大变化</em></strong></p>
<p>ExtractTextPlugin 1.0.0 不能在webpackv2下工作。你需要明确地安装ExtractTextPlugin v2<br>ExtractTextPlugin.extract</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: /.css$/,</span><br><span class="line">-      loader: ExtractTextPlugin.extract(&quot;style-loader&quot;, &quot;css-loader&quot;, &#123; publicPath: &quot;/dist&quot; &#125;)</span><br><span class="line">+      use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">+        fallback: &quot;style-loader&quot;,</span><br><span class="line">+        use: &quot;css-loader&quot;,</span><br><span class="line">+        publicPath: &quot;/dist&quot;</span><br><span class="line">+      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>new ExtractTextPlugin({options})</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">-  new ExtractTextPlugin(&quot;bundle.css&quot;, &#123; allChunks: true, disable: false &#125;)</span><br><span class="line">+  new ExtractTextPlugin(&#123;</span><br><span class="line">+    filename: &quot;bundle.css&quot;,</span><br><span class="line">+    disable: false,</span><br><span class="line">+    allChunks: true</span><br><span class="line">+  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong><em>6.对CLI参数的限制</em></strong></p>
<p>webpackV2版本不再允许用户传递一些自定义参数了，例如之前的–mockport已经不再允许了。webpackV2版本维护了一个命令参数对照表（schema），在执行webpack命令时，webpack会挨个参数的去查看是否在schema中。虽然不能自定义命令，但现在提供了一个接口 来传递参数给配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack --env.mockport 8888</span><br></pre></td></tr></table></figure>
<p><strong>能给我们带来什么</strong></p>
<p><strong><em>tree shaking</em></strong><br>涉及知识点：</p>
<ul>
<li><p>es6模块静态结构</p>
<p>  ES6模块系统中，模块不是对象，而是声明式的代码集合，模块导入定义也是声明式的。import是在编译时resolve的——即在脚本开始执行之前。事实上，各个模块之间的依赖关系图所涉及的所有imports和exports都是在执行之前resolve好了。那么这么说来如果我们需要按需加载模块，es6是不是就不能完成了呢？其实不是的，es6也有模块动态加载的API。</p>
<p>  es6的静态特性和commonJS的动态特性相比有哪些区别：</p>
<ul>
<li>只能作为模块顶层的语句出现，不能出现在 function 里面或是 if 里面。</li>
<li>import 的模块名只能是字符串常量。</li>
<li>不管 import 的语句出现的位置在哪里，在模块初始化的时候所有的 import 都必须已经导入完成。换句话说，ES6 imports are hoisted。</li>
<li><p>import binding 是 immutable 的，类似 const。比如说你不能 import { a } from ‘./a’ 然后给 a 赋值个其他什么东西。</p>
<p>这些设计虽然使得灵活性不如 CommonJS 的 require，但却保证了 ES6 modules 的依赖关系是确定 (deterministic) 的，和运行时的状态无关，从而也就保证了 ES6 modules 是可以进行可靠的静态分析的。</p>
</li>
</ul>
</li>
<li><p>es6模块动态加载（实现懒加载）</p>
<p>  使用System.import来实现按需加载</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">System.import(&apos;./B&apos;).then(</span><br><span class="line">   moduleB=&gt;&#123;</span><br><span class="line">        let b = new moduleB();</span><br><span class="line">        b.render();</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>  每次import，webpack都会新建一个bundle，和之前的require类似，它返回的是一个promise，可以捕获错误进行处理：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">System.import(&apos;./B&apos;).then(</span><br><span class="line">   moduleB=&gt;&#123;</span><br><span class="line">        let b = new moduleB();</span><br><span class="line">        b.render();</span><br><span class="line">    &#125;</span><br><span class="line">).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>presets为什么必须要写成[[“es2015”,{modules:false}]]数组嵌套的形式</p>
</li>
<li><p>tree shaking原理（<a href="http://www.open-open.com/lib/view/open1483144941161.html" target="_blank" rel="external">相关文章</a>）</p>
<p>  实际上是无用代码移除（DCE, dead code elimination）的一种实现方式，但tree shaking不能消除带有副作用的代码，什么是副作用，例如上述文章示例2</p>
</li>
</ul>
<p><strong><em>Webpack可视化资源分析工具</em></strong></p>
<ul>
<li><p>webpack chart</p>
<p>  <a href="http://alexkuz.github.io/webpack-chart/" target="_blank" rel="external">demo地址</a></p>
</li>
<li><p>webpack-visualizer</p>
<p>  <a href="http://chrisbateman.github.io/webpack-visualizer/" target="_blank" rel="external">demo地址</a></p>
</li>
</ul>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://kusokaiser.github.io/2017/04/14/webpack2.0/" data-id="cj4s7mhwm000d5spcyf7lmcqf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webpack/">webpack</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="[post]-mysql导入和导出" class="article article-type-[post]" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/18/mysql导入和导出/" class="article-date">
  <time datetime="2016-05-18T08:16:50.000Z" itemprop="datePublished">2016-05-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/18/mysql导入和导出/">mysql数据库导出和导入</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、命令"><a href="#一、命令" class="headerlink" title="一、命令"></a>一、命令</h1><p>1.导出：<br>mysqldump -u root（用户名） -p  –password=123456（密码）–database ccnet-db（数据库名） &gt; ccnet-db.sql（.sql类型的导出文件）</p>
<p>2.导入：<br>首先执行：<br>mysql -uroot -p 根据提示输入密码<br>再&gt;&gt;source 路径/ccnet-db.sql(.sql类型的导出文件)</p>
<h1 id="二、shell脚本"><a href="#二、shell脚本" class="headerlink" title="二、shell脚本"></a>二、shell脚本</h1><p>1.导出<br>新建export.sh<br>chmod +x export.sh<br>文件内容：</p>
<p>#! /bin/bash<br>mysqldump -u root -p –password=123456 –databases ccnet-db &gt; ccnet-db.sql &amp;&amp; echo “Export database to current dir successfully! Please check the files!”（在文件中写死密码）</p>
<p>可以将单个数据库导出，也可以将多个数据库导出：<br>导出三个数据库为一个文件：<br>mysqldump -u root -p$1 -h$2  –databases ccnet-db  seahub-db seafile-db&gt; all.sql（命令参数携带密码和ip）<br>（执行的时候需要执行 ./export.sh 123456 localhost) 其中123456是数据库访问密码，localhost是数据库ip，localhost代表本地数据库<br>导出全部数据库（慎用,因为可能会导入其他系统（应用）的mysql）：<br>mysqldump -u root -p$1 -h$2  –events –ignore-table=mysql.events –all-databases &gt; all.sql</p>
<p>2.导入<br>新建import.sh<br>chmod +x import.sh<br>文件内容：</p>
<p>#!/bin/bash</p>
<p>#导入数据库的过程需要一段时间</p>
<p>mysql -uroot -p –password=123456 -e “source ccnet-db.sql;” &amp;&amp; echo “Import database successfully!”      #(-e后边的是数据库语句，每条数据库语句后面要跟；）<br>mysql -uroot -p$1-e “source ccnet-db.sql;” &amp;&amp; echo “Import database successfully!” </p>
<p><a href="http://www.cnblogs.com/feichexia/p/MysqlDataBackup.html" target="_blank" rel="external">http://www.cnblogs.com/feichexia/p/MysqlDataBackup.html</a><br><a href="http://www.360doc.com/content/15/0128/09/14187254_444374564.shtml" target="_blank" rel="external">http://www.360doc.com/content/15/0128/09/14187254_444374564.shtml</a></p>
<p><a href="http://blog.csdn.net/shellching/article/details/8129687" target="_blank" rel="external">http://blog.csdn.net/shellching/article/details/8129687</a></p>
<p>脚本增加对参数的判断：<br><a href="http://www.jb51.net/article/56549.htm" target="_blank" rel="external">http://www.jb51.net/article/56549.htm</a><br>    if [ $# != 2 ] ; then<br>    echo “ USAGE: Two parameters are needed!”<br>    echo “FORMAT: $0 [mysqldb_password][mysqldb_ip]”<br>    echo “  e.g.: $0 123456 localhost”<br>    exit 1;<br>    fi<br>上述代码判断参数个数不为2时，给出usgae提示。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://kusokaiser.github.io/2016/05/18/mysql导入和导出/" data-id="cj4s7mhwa00065spc0i5ckmdw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/">mysql</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="[post]-RabbitMQ" class="article article-type-[post]" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/07/RabbitMQ/" class="article-date">
  <time datetime="2016-04-07T08:16:50.000Z" itemprop="datePublished">2016-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/07/RabbitMQ/">RabbitMQ相关笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>RabbitMQ的几种应用场景;<br><a href="http://blog.csdn.net/zyz511919766/article/details/41946521" target="_blank" rel="external">http://blog.csdn.net/zyz511919766/article/details/41946521</a></p>
<p>实际开发过程中，采用的是<br><img src="http://i.imgur.com/odSK981.jpg" alt=""></p>
<p>开发的系统为secfile，预先在RabbitMQ服务端定义好了“secfile”队列，consumer指定用secfile队列来接收消息：</p>
<pre><code>#!/usr/bin/env python
#coding:utf-8
import requests
import logging
import pika
import json
import os
os.environ.setdefault(&quot;DJANGO_SETTINGS_MODULE&quot;,     &quot;seahub.settings&quot;)
import sys
sys.path.append(&quot;../..&quot;)
from seahub.settings import PIKA_CREDENTIALS_ID,     PIKA_CREDENTIALS_PASSWORD,     PIKA_CONNECTION_ADDR,PIKA_CONNECTION_PORT,     PIKA_CONNECTION_NAME
from OauthDataOp import OauthDataOp

oauthdataop =OauthDataOp()

def callback(ch, method, properties, body):
print &quot; [x] Received %s&quot; % (body,)
action=json.loads(body)[&apos;action&apos;]
print &quot; [x] ACTION %s&quot; % (action)

if action==&apos;CreateCompany&apos;:
    name=json.loads(body)[&apos;name&apos;]
    company_id=json.loads(body)[&apos;company_id&apos;]
    email=json.loads(body)[&apos;email&apos;]
    phone=json.loads(body)[&apos;phone&apos;]
    address=json.loads(body)[&apos;address&apos;]
    applier_email=json.loads(body)[&apos;applier_email&apos;]
    result=oauthdataop.company_create(name,company_id,email,phone,address,applier_email)
    print &apos;CreateCompany&apos;
    print result[&apos;status&apos;]


elif action==&apos;AddToCompany&apos; or action==&apos;ExitCompany&apos;:
    email=json.loads(body)[&apos;email&apos;]
    company_id=json.loads(body)[&apos;company_id&apos;]
    company_name=json.loads(body)[&apos;company_name&apos;]
    if action==&quot;AddToCompany&quot;:
        result=oauthdataop.user_joincom(email,company_id,company_name)
        print &apos;AddToCompany&apos;
        print result[&apos;status&apos;]
    else:
        result=oauthdataop.user_quitcom(email,company_id,company_name)
        print &apos;ExitCompany&apos;
        print result[&apos;status&apos;]
    #return result
elif action==&apos;ApplyAdmin&apos;:
    company_id=json.loads(body)[&apos;company_id&apos;]
    company_name=json.loads(body)[&apos;company_name&apos;]
    applier_email=json.loads(body)[&apos;applier_email&apos;]
    result=oauthdataop.user_beadmin(company_id,company_name,applier_email)
    print &apos;ApplyAdmin&apos;
    print result[&apos;status&apos;]
    #return result


elif action==&apos;CreateProjectGroup&apos;:
    email=json.loads(body)[&apos;email&apos;]
    project_group_id=json.loads(body)[&apos;project_group_id&apos;]
    company_id=json.loads(body)[&apos;company_id&apos;]
    company_name=json.loads(body)[&apos;company_name&apos;]
    project_group_name=json.loads(body)[&apos;project_group_name&apos;]
    project_group_Enname=json.loads(body)[&apos;project_group_Enname&apos;]
    result=oauthdataop.group_create(email,project_group_id,project_group_name,company_id,company_name)
    print &apos;CreateProjectGroup&apos;
    print result[&apos;status&apos;]
    #return result


elif action==&apos;DestributeMember&apos;:
    company_id=json.loads(body)[&apos;company_id&apos;]
    project_group_id=json.loads(body)[&apos;project_group_id&apos;]
    company_name=json.loads(body)[&apos;company_name&apos;]
    project_group_name=json.loads(body)[&apos;project_group_name&apos;]
    employee_email=json.loads(body)[&apos;employee_email&apos;]
    result=oauthdataop.user_joingro(employee_email,project_group_id,project_group_name,company_id,company_name)
    print &apos;DestributeMember&apos;
    print result[&apos;status&apos;]
    #return result


elif action==&apos;DeleteMember&apos;:
    email=json.loads(body)[&apos;email&apos;]
    company_name=json.loads(body)[&apos;company_name&apos;]
    project_group_name=json.loads(body)[&apos;project_group_name&apos;]
    company_id=json.loads(body)[&apos;company_id&apos;]
    project_group_id=json.loads(body)[&apos;project_group_id&apos;]
    result=oauthdataop.user_quitgro(email,project_group_id,project_group_name,company_id,company_name)
    print &apos;DeleteMember&apos;
    print result[&apos;status&apos;]
    #return result


elif action==&apos;SetLeader&apos; or action==&apos;CancelLeader&apos;:
    company_id=json.loads(body)[&apos;company_id&apos;]
    email=json.loads(body)[&apos;email&apos;]
    group_id=json.loads(body)[&apos;group_id&apos;]
    projectGroupName=json.loads(body)[&apos;projectGroupName&apos;]
    if action==&apos;SetLeader&apos;:
        result=oauthdataop.set_groleader(email,group_id,projectGroupName,company_id)
        print &apos;SetLeader&apos;
        print result[&apos;status&apos;]
    else:
        result=oauthdataop.cancel_groleader(email,group_id,projectGroupName,company_id)
        print &apos;CancelLeader&apos;
        print result[&apos;status&apos;]
    #return result


elif action==&apos;RegistUser&apos;:
    user_name=json.loads(body)[&apos;user_name&apos;]
    user_email=json.loads(body)[&apos;user_email&apos;]
    result=oauthdataop.user_register(user_name,user_email)
    print &apos;RegistUser&apos;
    print result[&apos;status&apos;]
    #return result


elif action==&apos;UpdateUser&apos;:
    user_name=json.loads(body)[&apos;user_name&apos;]
    name=json.loads(body)[&apos;name&apos;]
    user_email=json.loads(body)[&apos;user_email&apos;]
    user_phone=json.loads(body)[&apos;user_phone&apos;]
    user_sex=json.loads(body)[&apos;user_sex&apos;]
    user_address=json.loads(body)[&apos;user_address&apos;]
    result=oauthdataop.user_update(user_name,name,user_email)
    print &apos;UpdateUser&apos;
    print result[&apos;status&apos;]
    if result[&apos;status&apos;]==&apos;failed&apos;:
        print result[&apos;err_msg&apos;]
    #return result


elif action==&apos;UpdateUserFaceImage&apos;:
    user_name=json.loads(body)[&apos;user_name&apos;]
    user_email=json.loads(body)[&apos;user_email&apos;]
    user_portrait=json.loads(body)[&apos;user_portrait&apos;]
    print &apos;UpdateUserFaceImage&apos;

else:
    print &quot;undentified action!&quot;
</code></pre><p>class Rabbitmq(object):</p>
<pre><code>QUEUE_NAME = &apos;&apos;
EXCHANGE_NAME = &apos;&apos;



def __init__(self,queue_name=&apos;secfile&apos;,exchange_name=&apos;demo&apos;):
    self.QUEUE_NAME=queue_name
    self.EXCHANGE_NAME=exchange_name

    credentials = pika.PlainCredentials(PIKA_CREDENTIALS_ID, PIKA_CREDENTIALS_PASSWORD)#用户名和密码
    connection = pika.BlockingConnection(pika.ConnectionParameters(PIKA_CONNECTION_ADDR, PIKA_CONNECTION_PORT, PIKA_CONNECTION_NAME, credentials))
    global channel
    channel = connection.channel()

    channel.queue_declare(queue_name, auto_delete=False)
    channel.queue_bind(queue_name, exchange_name, queue_name)
    channel.basic_consume(callback, queue_name, consumer_tag=&apos;sec&apos;,no_ack=True)

    #global oauthdataop
    #oauthdataop=OauthDataOp()


def start_monitor(self):
    print &apos;start monitor&apos;
    print &apos; [*] Waiting for messages. To exit press CTRL+C&apos;
    channel.start_consuming()

def pause_monitor(self):
    print &apos;pause monitor&apos;
    channel.stop_consuming()


def stop_monitor(self):
    print &apos;stop monitor&apos;
    channel.queue_delete(self.QUEUE_NAME)
</code></pre><p>############################以下是测试代码#####################################<br>    if <strong>name</strong>==’<strong>main</strong>‘:<br>    mq=Rabbitmq()<br>    mq.start_monitor()</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://kusokaiser.github.io/2016/04/07/RabbitMQ/" data-id="cj4s7mhw700035spc13m4id46" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rabbitMQ/">rabbitMQ</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="[post]-windows下搭建react-native开发环境" class="article article-type-[post]" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/07/windows下搭建react-native开发环境/" class="article-date">
  <time datetime="2016-04-07T07:16:50.000Z" itemprop="datePublished">2016-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/07/windows下搭建react-native开发环境/">windows下搭建react-native开发环境</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>0.前提：</p>
<p>安装好NPM，git，node，jdk</p>
<p>1.安装android SDK（地址：<a href="http://developer.android.com/sdk/index.html" target="_blank" rel="external">http://developer.android.com/sdk/index.html</a>）<br>可以单独安装sdk，也可以下载安装android studio，会一并安装好sdk（推荐后者）</p>
<p>2.安装react-native命令行工具<br><code>npm install -g react-native-cli</code></p>
<p>3.创建项目目录（如Myreact)，进入目录后执行：<br><code>react-native init Myreact</code><br>此步需要等待较长时间，如报错，可先执行<code>npm start</code>，再执行此命令</p>
<p>4.运行packager：<br>react-native start<br>如果此命令找不到或失败，也可进入Myreact\react native\MyProject\node_modules\react-native\local-cli下执行：<br>node cli.js start（原因：进入Myreact\react native\MyProject\node_modules\react-native\packager目录下打开packager.sh文件，会看到如下内容：<br><img src="http://i.imgur.com/K6txYyW.png" alt=""><br>其中最后一行揭示了start命令的执行位置<br>运行packager时可能会遇到的问题：<br>a.ERROR Watcher took too long to load：请尝试修改node_modules/react-native/packager/react-packager/src/FileWatcher/index.js，将其中的MAX_WAIT_TIME 从25000改为更大的值（单位是毫秒）<br>b.TransformError: /Users/…/node_modules/alt/lib/index.js: [BABEL] /Users/…/node_modules/alt/lib/index.js: Unknown option: /Users/…/node_modules/alt/.babelrc.stage，将错误路径中的.babelrc文件删除即可。<br>成功运行packager后，可以在<a href="http://localhost:8081/index.android.bundle?platform=android" target="_blank" rel="external">http://localhost:8081/index.android.bundle?platform=android</a>这个地址中访问到类似如下内容：<br><img src="http://i.imgur.com/XCJ7LMf.png" alt=""><br>之后保持启动packager的cmd窗口不要关闭</p>
<p>5.安装安卓模拟器，推荐genymotion（<a href="https://www.genymotion.com/" target="_blank" rel="external">https://www.genymotion.com/</a>）对个人用户是免费的，在genymotion中添加一个模拟设备，之后在settings中设置模拟器的sdk为当前环境的sdk地址<br><img src="http://i.imgur.com/pqI7fnE.jpg" alt=""></p>
<p>6.启动设备，点击start启动模拟器，启动中可能会报错，提示intel HAXM相关错误信息，此时需要在sdk目录下\extras\intel\Hardware_Accelerated_Execution_Manager路径中安装intelhaxm-android，安装过程中，又有可能提示电脑没有开启vt-x功能，此时需要重启电脑并进入bios中开启对应的功能，一般情况是在advanced下的Intel  Virtualization Technology功能开启为enabled即可，随后再安装intelhaxm-android成功，之后可以成功启动安卓模拟器了</p>
<p>7.启动模拟器后再进入工程目录，即Myreact/下执行 react-native run-android命令，等待片刻，会在刚才启动的模拟器中看到如下画面：<br><img src="http://i.imgur.com/XbxxxoB.png" alt=""></p>
<p>8.修改其中显示内容，只需修改index.android.js文件，随后在menu中点击ReloadJS<br><img src="http://i.imgur.com/RVJm2wD.png" alt=""><br>如过程中遇到其他错误请参考<a href="http://www.cnblogs.com/meteoric_cry/p/4874517.html" target="_blank" rel="external">http://www.cnblogs.com/meteoric_cry/p/4874517.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://kusokaiser.github.io/2016/04/07/windows下搭建react-native开发环境/" data-id="cj4s7mhwp000g5spc1m17nrxe" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react-native/">react-native</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/移动web/">移动web</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="[post]-python 在不同层级目录import 模块的方法" class="article article-type-[post]" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/28/python 在不同层级目录import 模块的方法/" class="article-date">
  <time datetime="2016-03-28T07:26:50.000Z" itemprop="datePublished">2016-03-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/28/python 在不同层级目录import 模块的方法/">python 在不同层级目录import 模块的方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、同级目录下的调有"><a href="#一、同级目录下的调有" class="headerlink" title="一、同级目录下的调有"></a>一、同级目录下的调有</h2><p>程序结构如下：<br>   – src<br>       |– mod1.py<br>       |– test1.py<br>若在程序test1.py中导入模块mod1, 则直接使用<br>   import mod1<br>   或<br>   from mod1 import *;</p>
<h2 id="二、调用子目录下的模块"><a href="#二、调用子目录下的模块" class="headerlink" title="二、调用子目录下的模块"></a>二、调用子目录下的模块</h2><p>程序结构如下：<br>   – src<br>       |– mod1.py<br>       |– lib<br>       |– mod2.py<br>       |– test1.py<br>这时看到test1.py和lib目录（即mod2.py的父级目录），如果想在程序test1.py中导入模块mod2.py ，可以在lib件夹中建立空文件<strong>init</strong>.py文件(也可以在该文件中自定义输出模块接口)，然后使用：<br>  from lib.mod2 import *<br>  或<br>  import lib.mod2.</p>
<h2 id="三、调用上级目录下的文件"><a href="#三、调用上级目录下的文件" class="headerlink" title="三、调用上级目录下的文件"></a>三、调用上级目录下的文件</h2><p>程序结构如下：<br>  – src<br>       |– mod1.py<br>       |– lib<br>       |– mod2.py<br>       |– sub<br>       |– test2.py<br>这里想要实现test2.py调用mod1.py和mod2.py ，做法是我们先跳到src目录下面，直接可以调用mod1，然后在lib上当下建一个空文件<strong>init</strong>.py ，就可以像第二步调用子目录下的模块一样，通过import  lib.mod2进行调用了。具体代码如下：<br>1.<code>import sys</code><br>2.<code>sys.path.append(&quot;..&quot;)</code><br>3.<code>import mod1</code><br>4.<code>import mod2.mod2</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://kusokaiser.github.io/2016/03/28/python 在不同层级目录import 模块的方法/" data-id="cj4s7mhwh000b5spclzdzjngx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="[post]-how to build es6 in Webstorm" class="article article-type-[post]" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/16/how to build es6 in Webstorm/" class="article-date">
  <time datetime="2016-03-16T03:16:50.000Z" itemprop="datePublished">2016-03-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/16/how to build es6 in Webstorm/">webstorm如何配置使用es6</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>0.前提：</p>
<p>安装好NPM，执行<code>npm -g install babel-cli</code>命令，注意，以前是执行<code>npm -g install babel</code>命令，新版本后要求执行<code>npm -g install babel-cli</code>命令。</p>
<p>1.加入es6语法<br><img src="http://i.imgur.com/EPtr0UK.png" alt=""><br> 配置为<br><img src="http://i.imgur.com/CNuYcgj.png" alt=""><br>配置后，在js文件中写es6语法的语句不会提示错误。</p>
<p>2.添加file-watcher:<br><img src="http://i.imgur.com/Sbj3Z88.png" alt=""><br>点击右上角+号添加babel，配置窗口如下所示：<br><img src="http://i.imgur.com/zNN78iS.png" alt=""><br>其中file Type一项可以自行配置，如javascript。</p>
<p>3.在项目目录执行<code>npm install --save-dev babel-preset-es2015</code>，后在项目根路径下新建.babelrc文件，内容为：<br>{<br>  “presets”: [“es2015”]<br>}<br>随后在webstorm中新建.es6文件并添加es6语句，会看到翻译后的.js文件</p>
<p><img src="http://i.imgur.com/IuaZttI.png" alt=""><br>  翻译后为：<br><img src="http://i.imgur.com/2LPkF6U.png" alt=""></p>
<p>tips:如何新建不带文件名的.babelrc文件？<br>新建一个.txt文本文件，在其中输入想要加入到.babelrc文件中的内容，然后点击另存为，在弹出的文件名位置，输入”.babelrc”(注意：两边一定要用双引号括起来)，保存即可。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://kusokaiser.github.io/2016/03/16/how to build es6 in Webstorm/" data-id="cj4s7mhwc00075spclbmfitqo" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/">es6</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webstorm/">webstorm</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="[post]-newArticle" class="article article-type-[post]" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/02/newArticle/" class="article-date">
  <time datetime="2016-03-02T08:16:50.000Z" itemprop="datePublished">2016-03-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
<div class="article-gallery">
  <div class="article-gallery-photos">
    
      <a class="article-gallery-img fancybox" href="http://bruce.u.qiniudn.com/2013/11/27/reading/photos-0.jpg" rel="gallery_cj4s7mhwe00085spcejs7404z">
        <img src="http://bruce.u.qiniudn.com/2013/11/27/reading/photos-0.jpg" itemprop="image">
      </a>
    
      <a class="article-gallery-img fancybox" href="http://bruce.u.qiniudn.com/2013/11/27/reading/photos-1.jpg" rel="gallery_cj4s7mhwe00085spcejs7404z">
        <img src="http://bruce.u.qiniudn.com/2013/11/27/reading/photos-1.jpg" itemprop="image">
      </a>
    
  </div>
</div>

    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/02/newArticle/">hexo+github个人博客搭建</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>准备前提：安装好Node，安装好git，并有github账号</p>
<p>Node和Git都安装好后，可执行如下命令安装hexo：<br>    <code>npm install -g hexo</code><br>初始化<br>然后，执行init命令初始化hexo到你指定的目录，我是直接cd到目标目录执行hexo init的。命令：<br>    <code>hexo init</code><br>好啦，至此，全部安装工作已经完成！<br>本地启动：<code>hexo server</code><br>后访问localhost:4000</p>
<p>配置github：<br>建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】，固定写法，然后建立关联，我的blog在本地d:/hexo，hexo是我之前建的东西也全在这里面，有：<br>_config.yml    node_modules    publicsourcedb.json      package.json    scaffolds    themes<br>修改_config.yml中的deploy：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/kusokaiser/kusokaiser.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p>
<p>注意：冒号后需加一个空格！！<br>后执行npm install hexo-deployer-git –save命令（如不执行会报error deployer not found错误）<br>最后执行：<br>hexo clean<br>hexo g<br>hexo d<br>生成+部署完成，可访问<a href="http://kusokaiser.github.io">http://kusokaiser.github.io</a> 来查看更新后的博客</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://kusokaiser.github.io/2016/03/02/newArticle/" data-id="cj4s7mhwe00085spcejs7404z" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hexo/">hexo</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/02/hello-world/" class="article-date">
  <time datetime="2016-03-02T02:35:26.750Z" itemprop="datePublished">2016-03-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/02/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://kusokaiser.github.io/2016/03/02/hello-world/" data-id="cj4s7mhw900045spcrgxm7t8z" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/es6/">es6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rabbitMQ/">rabbitMQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react/">react</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react-native/">react-native</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web/">web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/">webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webstorm/">webstorm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/移动web/">移动web</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/es6/" style="font-size: 10px;">es6</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/python/" style="font-size: 20px;">python</a> <a href="/tags/rabbitMQ/" style="font-size: 10px;">rabbitMQ</a> <a href="/tags/react/" style="font-size: 15px;">react</a> <a href="/tags/react-native/" style="font-size: 10px;">react-native</a> <a href="/tags/web/" style="font-size: 10px;">web</a> <a href="/tags/webpack/" style="font-size: 10px;">webpack</a> <a href="/tags/webstorm/" style="font-size: 10px;">webstorm</a> <a href="/tags/移动web/" style="font-size: 10px;">移动web</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/07/06/20170707-React相关技巧和实践-郭琦/">React相关技巧和实践</a>
          </li>
        
          <li>
            <a href="/2017/05/18/React开发技巧-生命周期实战技巧/">React生命周期原理和实战技巧</a>
          </li>
        
          <li>
            <a href="/2017/04/14/webpack2.0/">Webpack2.0</a>
          </li>
        
          <li>
            <a href="/2016/05/18/mysql导入和导出/">mysql数据库导出和导入</a>
          </li>
        
          <li>
            <a href="/2016/04/07/RabbitMQ/">RabbitMQ相关笔记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Kuso Kaiser<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>